import { join } from 'node:path';
import { ESLintUtils } from '@typescript-eslint/utils';
import { createSyncFn } from 'synckit';
import { distDir } from './dirs.mjs';
import MagicString from 'magic-string';
import { AST_TOKEN_TYPES } from '@typescript-eslint/types';
import 'node:url';

const CLASS_FIELDS = ["class", "classname"];
const AST_NODES_WITH_QUOTES = ["Literal", "VLiteral"];

const syncAction = createSyncFn(join(distDir, "worker.mjs"));
const createRule = ESLintUtils.RuleCreator(
  () => "https://unocss.dev/integrations/eslint#rules"
);

const IGNORE_ATTRIBUTES = ["style", "class", "classname", "value"];
const orderAttributify = createRule({
  name: "order-attributify",
  meta: {
    type: "layout",
    fixable: "code",
    docs: {
      description: "Order of UnoCSS attributes"
    },
    messages: {
      "invalid-order": "UnoCSS attributes are not ordered"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const scriptVisitor = {};
    const templateBodyVisitor = {
      VStartTag(node) {
        const valueless = node.attributes.filter((i) => typeof i.key?.name === "string" && !IGNORE_ATTRIBUTES.includes(i.key?.name?.toLowerCase()) && i.value == null);
        if (!valueless.length)
          return;
        const input = valueless.map((i) => i.key.name).join(" ").trim();
        const sorted = syncAction(
          context.settings.unocss?.configPath,
          "sort",
          input
        );
        if (sorted !== input) {
          context.report({
            node,
            messageId: "invalid-order",
            fix(fixer) {
              const codeFull = context.getSourceCode();
              const offset = node.range[0];
              const code = codeFull.getText().slice(node.range[0], node.range[1]);
              const s = new MagicString(code);
              const sortedNodes = valueless.map((i) => [i.range[0] - offset, i.range[1] - offset]).sort((a, b) => b[0] - a[0]);
              for (const [start, end] of sortedNodes.slice(1))
                s.remove(start, end);
              s.overwrite(sortedNodes[0][0], sortedNodes[0][1], ` ${sorted.trim()} `);
              return fixer.replaceText(node, s.toString());
            }
          });
        }
      }
    };
    const parserServices = context?.sourceCode.parserServices || context.parserServices;
    if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const blocklist = createRule({
  name: "blocklist",
  meta: {
    type: "problem",
    fixable: "code",
    docs: {
      description: "Utilities in UnoCSS blocklist"
    },
    messages: {
      "in-blocklist": '"{{name}}" is in blocklist{{reason}}'
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const checkLiteral = (node) => {
      if (typeof node.value !== "string" || !node.value.trim())
        return;
      const input = node.value;
      const blocked = syncAction(
        context.settings.unocss?.configPath,
        "blocklist",
        input,
        context.filename
      );
      blocked.forEach(([name, meta]) => {
        context.report({
          node,
          messageId: "in-blocklist",
          data: {
            name,
            reason: meta?.message ? `: ${meta.message}` : ""
          }
        });
      });
    };
    const scriptVisitor = {
      JSXAttribute(node) {
        if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value) {
          if (node.value.type === "Literal")
            checkLiteral(node.value);
        }
      },
      SvelteAttribute(node) {
        if (node.key.name === "class") {
          if (node.value?.[0].type === "SvelteLiteral")
            checkLiteral(node.value[0]);
        }
      }
    };
    const templateBodyVisitor = {
      VAttribute(node) {
        if (node.key.name === "class") {
          if (node.value.type === "VLiteral")
            checkLiteral(node.value);
        }
      },
      // Attributify
      VStartTag(node) {
        const valueless = node.attributes.filter((i) => typeof i.key?.name === "string" && !IGNORE_ATTRIBUTES.includes(i.key?.name?.toLowerCase()) && i.value == null);
        if (!valueless.length)
          return;
        for (const node2 of valueless) {
          if (!node2?.key?.name)
            continue;
          const blocked = syncAction(
            context.settings.unocss?.configPath,
            "blocklist",
            node2.key.name,
            context.filename
          );
          blocked.forEach(([name, meta]) => {
            context.report({
              node: node2,
              messageId: "in-blocklist",
              data: {
                name,
                reason: meta?.message ? `: ${meta.message}` : ""
              }
            });
          });
        }
      }
    };
    const parserServices = context?.sourceCode.parserServices || context.parserServices;
    if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const enforceClassCompile = createRule({
  name: "enforce-class-compile",
  meta: {
    type: "problem",
    fixable: "code",
    docs: {
      description: "Enforce class compilation"
    },
    messages: {
      missing: "prefix: `{{prefix}}` is missing"
    },
    schema: [{
      type: "object",
      properties: {
        prefix: {
          type: "string"
        },
        enableFix: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }]
  },
  defaultOptions: [{ prefix: ":uno:", enableFix: true }],
  create(context, [mergedOptions]) {
    const CLASS_COMPILE_PREFIX = `${mergedOptions.prefix} `;
    const ENABLE_FIX = mergedOptions.enableFix;
    function report({ node, fix }) {
      context.report({
        node,
        loc: node.loc,
        messageId: "missing",
        data: { prefix: CLASS_COMPILE_PREFIX.trim() },
        fix: (...args) => ENABLE_FIX ? fix(...args) : null
      });
    }
    const scriptVisitor = {
      JSXAttribute(_node) {
      },
      SvelteAttribute(_node) {
      }
    };
    const reportClassList = (node, classList) => {
      if (classList.startsWith(CLASS_COMPILE_PREFIX))
        return;
      report({
        node,
        fix(fixer) {
          return fixer.replaceTextRange([node.range[0] + 1, node.range[1] - 1], `${CLASS_COMPILE_PREFIX}${classList}`);
        }
      });
    };
    const templateBodyVisitor = {
      [`VAttribute[key.name=class]`](attr) {
        const valueNode = attr.value;
        if (!valueNode || !valueNode.value)
          return;
        reportClassList(valueNode, valueNode.value);
      },
      [`VAttribute[key.argument.name=class] VExpressionContainer Literal:not(ConditionalExpression .test Literal):not(Property .value Literal)`](literal) {
        if (!literal.value || typeof literal.value !== "string")
          return;
        reportClassList(literal, literal.value);
      },
      [`VAttribute[key.argument.name=class] VExpressionContainer TemplateElement`](templateElement) {
        if (!templateElement.value.raw)
          return;
        reportClassList(templateElement, templateElement.value.raw);
      },
      [`VAttribute[key.argument.name=class] VExpressionContainer Property`](property) {
        if (property.key.type !== "Identifier")
          return;
        const classListString = property.key.name;
        if (classListString.startsWith(CLASS_COMPILE_PREFIX))
          return;
        report({
          node: property.key,
          fix(fixer) {
            let replacePropertyKeyText = `'${CLASS_COMPILE_PREFIX}${classListString}'`;
            if (property.shorthand)
              replacePropertyKeyText = `${replacePropertyKeyText}: ${classListString}`;
            return fixer.replaceTextRange(property.key.range, replacePropertyKeyText);
          }
        });
      }
    };
    const parserServices = context?.sourceCode.parserServices || context.parserServices;
    if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const order = createRule({
  name: "order",
  meta: {
    type: "layout",
    fixable: "code",
    docs: {
      description: "Order of UnoCSS utilities in class attribute"
    },
    messages: {
      "invalid-order": "UnoCSS utilities are not ordered"
    },
    schema: [
      {
        type: "object",
        properties: {
          unoFunctions: {
            type: "array",
            items: { type: "string" }
          },
          unoVariables: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [
    {
      unoFunctions: ["clsx", "classnames"],
      unoVariables: ["^cls", "classNames?$"]
      // for example `clsButton = ''` or `buttonClassNames = {}`
    }
  ],
  create(context) {
    let { unoFunctions = ["clsx", "classnames"], unoVariables = ["^cls", "classNames?$"] } = context.options[0] || {};
    unoFunctions = unoFunctions.map((name) => name.toLowerCase());
    function isUnoFunction(name) {
      return unoFunctions.includes(name.toLowerCase());
    }
    const unoVariablesRegexes = unoVariables.map((regex) => new RegExp(regex, "i"));
    function isUnoVariable(name) {
      return unoVariablesRegexes.some((reg) => reg.test(name));
    }
    function checkLiteral(node, addSpace) {
      if (typeof node.value !== "string" || !node.value.trim())
        return;
      const input = node.value;
      let sorted = syncAction(
        context.settings.unocss?.configPath,
        "sort",
        input
      ).trim();
      if (addSpace === "before")
        sorted = ` ${sorted}`;
      else if (addSpace === "after")
        sorted += " ";
      if (sorted !== input) {
        const nodeOrToken = node.type === "SvelteLiteral" ? { type: AST_TOKEN_TYPES.String, value: node.value, loc: node.loc, range: node.range } : node;
        context.report({
          node: nodeOrToken,
          loc: node.loc,
          messageId: "invalid-order",
          fix(fixer) {
            if (AST_NODES_WITH_QUOTES.includes(node.type))
              return fixer.replaceTextRange([node.range[0] + 1, node.range[1] - 1], sorted);
            else
              return fixer.replaceText(nodeOrToken, sorted);
          }
        });
      }
    }
    function checkTemplateElement(quasi) {
      const input = quasi.value.raw;
      if (!input)
        return;
      const getRange = () => {
        const text = context.sourceCode.getText(quasi);
        const raw = quasi.value.raw;
        if (!text.includes(raw))
          return;
        const rawStart = text.indexOf(raw);
        const start = quasi.range[0] + rawStart;
        const end = quasi.range[0] + rawStart + raw.length;
        if (start < quasi.range[0] || end > quasi.range[1])
          return;
        return [start, end];
      };
      const realRange = getRange();
      if (!realRange)
        return;
      let sorted = syncAction(
        context.settings.unocss?.configPath,
        "sort",
        input
      ).trim();
      if (/^\s/.test(input))
        sorted = ` ${sorted}`;
      if (/\s$/.test(input))
        sorted += " ";
      if (sorted !== input) {
        context.report({
          node: quasi,
          loc: quasi.loc,
          messageId: "invalid-order",
          fix(fixer) {
            const realRange2 = getRange();
            if (!realRange2)
              return null;
            return fixer.replaceTextRange(realRange2, sorted);
          }
        });
      }
    }
    function isPossibleLiteral(node) {
      return node.type === "Literal" || node.type === "TemplateLiteral" || node.type === "TaggedTemplateExpression";
    }
    function checkPossibleLiteral(...nodes) {
      nodes.forEach((node) => {
        if (!isPossibleLiteral(node))
          return;
        if (node.type === "Literal" && typeof node.value === "string") {
          return checkLiteral(node);
        }
        const isSimpleTemplateLiteral = (node2) => {
          return node2.expressions.length === 0 && node2.quasis.length === 1;
        };
        if (node.type === "TemplateLiteral" && isSimpleTemplateLiteral(node)) {
          return checkTemplateElement(node.quasis[0]);
        }
        const isStringRaw = (tag) => {
          return tag.type === "MemberExpression" && tag.object.type === "Identifier" && tag.object.name === "String" && tag.property.type === "Identifier" && tag.property.name === "raw";
        };
        if (node.type === "TaggedTemplateExpression" && isStringRaw(node.tag) && isSimpleTemplateLiteral(node.quasi)) {
          return checkTemplateElement(node.quasi.quasis[0]);
        }
        if (node.type === "TemplateLiteral" && node.expressions.length > 0 && node.quasis.length > 0) {
          return void node.quasis.forEach((quasi) => {
            checkTemplateElement(quasi);
          });
        }
      });
    }
    const scriptVisitor = {
      JSXAttribute(node) {
        if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value) {
          if (isPossibleLiteral(node.value))
            return checkPossibleLiteral(node.value);
          else if (node.value.type === "JSXExpressionContainer" && isPossibleLiteral(node.value.expression))
            return checkPossibleLiteral(node.value.expression);
        }
      },
      SvelteAttribute(node) {
        if (node.key.name === "class") {
          let checkExpressionRecursively = function(expression) {
            if (expression.type !== "ConditionalExpression")
              return;
            if (expression.consequent.type === "Literal") {
              checkLiteral(expression.consequent);
            }
            if (expression.alternate) {
              if (expression.alternate.type === "ConditionalExpression") {
                checkExpressionRecursively(expression.alternate);
              } else if (expression.alternate.type === "Literal") {
                checkLiteral(expression.alternate);
              }
            }
          };
          if (!node.value.length)
            return;
          node.value.forEach((obj, i) => {
            if (obj.type === "SvelteMustacheTag") {
              checkExpressionRecursively(obj.expression);
            } else if (obj.type === "SvelteLiteral") {
              const addSpace = node.value?.[i - 1]?.type === "SvelteMustacheTag" ? "before" : node.value?.[i + 1]?.type === "SvelteMustacheTag" ? "after" : void 0;
              checkLiteral(obj, addSpace);
            }
          });
        }
      },
      // for Future node types
      // https://typescript-eslint.io/play/#ts=5.8.3&showAST=es&fileType=.tsx&code=PTAEDMCcHsFtQBYBckAcDOAuEB3PA6AO1VgCt18BjOYVAQ0oGs6BzAU2EoBt0APAfgZIAlgDc2AFToAjALzUAJm1AAoEKG59OPXvgX4k6FUu51IywnVht09Sss29QAbxWhQSAJ6plAYS506OgAanRcAK7KsqD%2BgegAgpCQdJ6gAD4xAUEAIsKUItCWkKkZ6EiQwoQs6aCE4bDSbJA10sIslUg1dVxcLdDQXGx0hDXhhErglWwKANxuHt5%2BWei5%2BcKFZqnRAEps1JAKADxlFVUANKDDngB8c%2B5ePplxiclbT0GhEWwA2gC6dxAxmtChodAAKfCQyqocKGTDvEJhSJ-ACU8JOlRYcwAvsY9gFzIDCMCRo4IVDiLCsKC%2BPhYh8kT9fmjQBiqnMVNRCGUPDYkABGUDRcqRTmFHlIPkAJiFEDC6DYYu5nUlZQAzLKRYquTy2LxynR6egAHJWKKgADksEgAFoACyoXgWlSDTqmIKm6zo8qY0bjNiTQjTFRqMDoYSwVCDDSBbXLT3msnzC2oG38x2ga02qWOi1neaqgWgfiW6RcaBMC2geEWwiFNh5gvS0AAMhbpfLlfz7mcoAARAg2D1oH34VqLn2cNBIFwFKO5TxlNj8yiQ%2BpYNPlEgEMNQPXQ6AAAaFwVt3llGVni3gQZOw%2BgQD6coB6M1AABloO1KGEAKK8VDmIJ1kIA93FAG1QEGcAkDHPlT3bQspRA9xwIqFhkBrG89SrV9hElZIuAPQBRU0AODkjxPVt22vW8LXvQBJb0AGBVABBNQAwFzXMAD0lSMAklVkfSqA9OXjM1ZSTe5YIoo9MN4Q9u3PIsz0PKTQAAEmcPUDSNBNsRkpsyjg0AAGU%2BJYfBkhwRTb1AaQWBtb5RDMMEbRtdA4DYAAdAB9eyKhkQYUV%2BHSxL0iSjNOEyzIsvUrJsuyHKclzrE87zhF8th-JUtT9WSTSzW0lcgA&eslintrc=N4KABGBEBOCuA2BTAzpAXGYBfEWg&tsconfig=N4KABGBEDGD2C2AHAlgGwKYCcDyiAuysAdgM6QBcYoEEkJemy0eAcgK6qoDCAFutAGsylBm3TgwAXxCSgA&tokens=false
      CallExpression(node) {
        if (!(node.callee.type === "Identifier" && isUnoFunction(node.callee.name)))
          return;
        node.arguments.forEach((arg) => {
          if (isPossibleLiteral(arg)) {
            return checkPossibleLiteral(arg);
          }
          if (arg.type === "ConditionalExpression") {
            return checkPossibleLiteral(arg.consequent, arg.alternate);
          }
          if (arg.type === "LogicalExpression") {
            return checkPossibleLiteral(arg.left, arg.right);
          }
          function handleObjectExpression(node2) {
            node2.properties.forEach((p) => {
              if (p.type !== "Property")
                return;
              if (isPossibleLiteral(p.value)) {
                return checkPossibleLiteral(p.value);
              }
              if (p.value.type === "ObjectExpression") {
                return handleObjectExpression(p.value);
              }
            });
            const keys = node2.properties.filter((p) => p.type === "Property").map((p) => p.key);
            return checkPossibleLiteral(...keys);
          }
          if (arg.type === "ObjectExpression") {
            return handleObjectExpression(arg);
          }
        });
      },
      // https://typescript-eslint.io/play/#ts=5.8.2&showAST=es&fileType=.tsx&code=MYewdgzgLgBApgDygJwIYGEA2qIQHKoC2cMAvDAOQBeAtAIwAMDFAUCwPTswBuqyAlqgBGmEgBM4wbGij9wLUJFhSIAIQCuUKODKVCyeq0XQYKjVvAAmXQAN99GABIA3ohQZsuAsQC%2BNheAmZpraYADMtvZ0Tq5IaFg4%2BERwfjA4poFQbJwwIEIAVpKwElJ8qLLyxrBCUGAJXskQus4sMDASAGao6phQAFx6mDSWAA4IFAA0rTAA7vxQABYAonGoAzYdoggw83CEEDTAcGBQcMgwQgDmNDMLuzCnSDQiqMAA1jFu8Z5JvjZTbQQAxabTaAE8BhRCENRuNpj4WAiOFx0lV2pJpOU5GAAkoLrV6r84BBrOQQeiuj1%2BoNhmNJtMgTByeDIdDaXC2gifGkmlUgA&eslintrc=N4KABGBEBOCuA2BTAzpAXGYBfEWg&tsconfig=N4KABGBEDGD2C2AHAlgGwKYCcDyiAuysAdgM6QBcYoEEkJemy0eAcgK6qoDCAFutAGsylBm3TgwAXxCSgA&tokens=false
      VariableDeclarator(node) {
        if (node.id.type !== "Identifier" || !node.init || !isUnoVariable(node.id.name))
          return;
        if (isPossibleLiteral(node.init)) {
          return checkPossibleLiteral(node.init);
        }
        if (node.init.type === "TSAsExpression" && isPossibleLiteral(node.init.expression)) {
          return checkPossibleLiteral(node.init.expression);
        }
        function handleObjectExpression(node2) {
          node2.properties.forEach((p) => {
            if (p.type !== "Property")
              return;
            if (isPossibleLiteral(p.value)) {
              return checkPossibleLiteral(p.value);
            }
            if (p.value.type === "ObjectExpression") {
              return handleObjectExpression(p.value);
            }
          });
        }
        if (node.init.type === "ObjectExpression") {
          return handleObjectExpression(node.init);
        }
        if (node.init.type === "TSAsExpression" && node.init.expression.type === "ObjectExpression") {
          return handleObjectExpression(node.init.expression);
        }
      }
    };
    const templateBodyVisitor = {
      VAttribute(node) {
        if (node.key.name === "class") {
          if (node.value.type === "VLiteral")
            checkLiteral(node.value);
        }
      }
    };
    const parserServices = context?.sourceCode.parserServices || context.parserServices;
    if (parserServices == null || parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const plugin = {
  rules: {
    order,
    "order-attributify": orderAttributify,
    blocklist,
    "enforce-class-compile": enforceClassCompile
  }
};

const configsFlat = {
  plugins: {
    unocss: plugin
  },
  rules: {
    "unocss/order": "warn",
    "unocss/order-attributify": "warn"
  }
};

const configsRecommended = {
  plugins: ["@unocss"],
  rules: {
    "@unocss/order": "warn",
    "@unocss/order-attributify": "warn"
  }
};

const index = {
  ...plugin,
  configs: {
    recommended: configsRecommended,
    flat: configsFlat
  }
};

export { index as default };
